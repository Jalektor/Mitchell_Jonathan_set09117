% #######################################
% ########### FILL THESE IN #############
% #######################################
\def\mytitle{Algorithms and Data structures Coursework Report}
\def\mykeywords{Draughts, Algorithms, Data Structures, Console}
\def\myauthor{Jonathan Mitchell}
\def\contact{40311730@live.napier.ac.uk}
\def\mymodule{Algorithms \& Data Structures (SET09117)}
% #######################################
% #### YOU DON'T NEED TO TOUCH BELOW ####
% #######################################
\documentclass[10pt, a4paper]{article}
\usepackage[a4paper,outer=1.5cm,inner=1.5cm,top=1.75cm,bottom=1.5cm]{geometry}
\twocolumn
\usepackage{graphicx}
\graphicspath{{./images/}}
%colour our links, remove weird boxes
\usepackage[colorlinks,linkcolor={black},citecolor={blue!80!black},urlcolor={blue!80!black}]{hyperref}
%Stop indentation on new paragraphs
\usepackage[parfill]{parskip}
%% Arial-like font
\IfFileExists{uarial.sty}
{
    \usepackage[english]{babel}
    \usepackage[T1]{fontenc}
    \usepackage{uarial}
    \renewcommand{\familydefault}{\sfdefault}
}{
    \GenericError{}{Couldn't find Arial font}{ you may need to install 'nonfree' fonts on your system}{}
    \usepackage{lmodern}
    \renewcommand*\familydefault{\sfdefault}
}
%Napier logo top right
\usepackage{watermark}
%Lorem Ipusm dolor please don't leave any in you final report ;)
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}
%give us the Capital H that we all know and love
\usepackage{float}
%tone down the line spacing after section titles
\usepackage{titlesec}
%Cool maths printing
\usepackage{amsmath}
%PseudoCode
\usepackage{algorithm2e}

\titlespacing{\subsection}{0pt}{\parskip}{-3pt}
\titlespacing{\subsubsection}{0pt}{\parskip}{-\parskip}
\titlespacing{\paragraph}{0pt}{\parskip}{\parskip}
\newcommand{\figuremacro}[5]{
    \begin{figure}[#1]
        \centering
        \includegraphics[width=#5\columnwidth]{#2}
        \caption[#3]{\textbf{#3}#4}
        \label{fig:#2}
    \end{figure}
}

\lstset{
	escapeinside={/*@}{@*/}, language=C++,
	basicstyle=\fontsize{8.5}{12}\selectfont,
	numbers=left,numbersep=2pt,xleftmargin=2pt,frame=tb,
    columns=fullflexible,showstringspaces=false,tabsize=4,
    keepspaces=true,showtabs=false,showspaces=false,
    backgroundcolor=\color{white}, morekeywords={inline,public,
    class,private,protected,struct},captionpos=t,lineskip=-0.4em,
	aboveskip=10pt, extendedchars=true, breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941}
}

\thiswatermark{\centering \put(336.5,-38.0){\includegraphics[scale=0.8]{logo}} }
\title{\mytitle}
\author{\myauthor\hspace{1em}\\\contact\\Edinburgh Napier University\hspace{0.5em}-\hspace{0.5em}\mymodule}
\date{}
\hypersetup{pdfauthor=\myauthor,pdftitle=\mytitle,pdfkeywords=\mykeywords}
\sloppy
% #######################################
% ########### START FROM HERE ###########
% #######################################
\begin{document}
    \maketitle
    \begin{abstract} 
        hello.
    \end{abstract}
    
    \textbf{Keywords -- }{\mykeywords}
    
    \section{Introduction}
    \paragraph{Create the game Draughts}
    The objective of this report is to create the game draughts in a chosen language and a chosen format - console/form/WPF or similar. Particular attention is to be placed on the Data Structures and Algorithms used.
    
    The game, at the very least, should allow for 2 human players to play against each other. Adding "AI" algorithms to allow for Player vs Computer, or even Computer vs Computer are optional additions. Based on development capabilities within the Project time-scale. Additional features such as undo or redo a move are also beneficial.
    
    Adding the ability to record the results of games and even record games themselves is another possibility. Finally Creative freedom is encourage during the development. An individual uniqueness is preferred when developing the game of Draughts.
    
    The application associated with this report was created using a console application. Written in c\#
    \section{Design}
    \subsection{{Player vs Player}}
    This began with creating a simple game board. Populated with elements from string array tiles. Allowing the player the ability to select the co-ordinates that will be populated with the draughts counters. Creating the concept of moving across the board was based off a Noughts \& Crosses game developed beforehand. 
    The data structures used are the following:
    
    $\bullet$ Arrays: Used for:
    
    $\ast$ Creating the elements for the board.
    	 
    $\ast$ Getting the letter \& number of end position after successfully capturing an opponents piece.
    
    $\bullet$ Stacks: 
    Used for the undo \& redo feature
    
    $\bullet$ Lists:
    Used for computer AI.  Stores the starting locations of all pieces on the board. The idea was to replace the element value with the new position of a piece, after it has been moved successfully. Also items are removed when they have been captured by the challenging player or computer. Lists were chosen for this as they are memory-dynamic data structures in nature and adding or removing elements is done without the need to instantiate new lists of various sizes. A do while loop is used to keep the cycle of player 1 moves -> player 2 moves etc. until either players pieces is 0. The game then ends displaying the winner. The application then closes or goes back to main menu?
    
    Broken down into stages, the design was created:
    
    $\bullet$ movement
    
    $\bullet$ preventing sideways movement 
       
    $\bullet$ preventing backwards movement
     
    $\bullet$ Limiting forward movement to only available diagonal positions
    
    $\bullet$ Checking for opponent marker
    
    $\bullet$ Capturing Opponent marker if possible
    
    $\bullet$ Checking if there is a second opponent marker can be taken
    
    The following classes were created:
    
    $\bullet$ Board
    
    $\bullet$ Movement
    
    $\bullet$ PlayerA
    
    $\bullet$ PlayerB
    
    $\bullet$ Error
    
    $\bullet$ Redo/Undo
    
    $\bullet$ Skynet
    
    $\bullet$ Hal
    
    The PlayerA, PlayerB, Skynet \& Hal classes all inherit from Movement class, This is due to the fact hey all share similar functions and use the same variables.
    
    Originally, all code created was first developed within the Board class. After testing to ensure it performs correctly. The code was split up into functions onto moved to the relevant class.
    
    For loops, with IF statements, were used to validate movement possible: only forward diagonal possible. Checking for an enemy piece, capturing it, if possible and checking to capture a second piece were all moved into separate functions.
    
    Undo/Redo was implemented using stacks . This allowed simple push/pop function to add/remove player move. By pushing the move input onto the undo stack. It can be popped to be used to reset the player's move. Subsequently, pushing it to the Redo Stacks if the player chooses to redo the undone move.    
    \subsubsection{Player 1}
    Player 1 development began by implementing each section of design and testing to ensure it works. First thing is to ask the user to input the starting coords of a player piece and the end coords - where the player wants the player piece to go.
    These are first checked to ensure they are not blank. After this both string are inserted into respective char arrays, For later validation and used to determinf ifcapturing opponents pieces is possible.
    
    The next level of validation is to check the starting coords are in the array of the checker board. If not tells the user If they are present. The endcoords are then check to ensure they are in the array tiles and this location does not already contain a player piece.
    
    Preventing sideways movement was the easiest to do - simply checking if the letter from the inputed endcoords does not match the starting letter coord by using the first index of the char arrays of both start coords and endcoords. If this passes backwards validation is next.
    
    Backwards validation is done by checking when the value of start coords equals the value of letter array in a for loop. the value of the int, used in the for loop, at this point is then stored. The same is done with the endcoord. The values of these ints are then  compared. If the value for the endcoord is less than the startcoord means the endcoord is a coord that is behind the startcoord. the function returns false as backwards move is not a legal move for standard pieces. Else returns true. The movement is not backwards. As sideways movement has also been validated. All that is left is forward movement.
    
    Forward movement is firstly validated by comparing the first index of each char array for startcoord \& endcoord. If the destination value is +1 of the start coord then it is forward movement by one row. Anything else assumes it is movement forward by more than one row. Which would not be a valid move. Then the number, second index value, is checked. If the destination coord is +/- 1 of the start coord. It is the forward diagonal of the start coord. Anything else is invalid.
    
    After this, the player piece is moved from the startcoord to the destination coord. An option to undo this move is made available. The undo process is detailed later in this report. The player turn variable is +/- 1 to allow the second player to move a piece.
    \subsubsection{Capture opponent piece}
    If there is an opponents piece detected in the destination coord for player piece. Then the capture piece function occurs:
    
    First thing to occur is finding the coords of the forward diagonal AFTER the current destination, based on the position of the starting coord of the player piece. This is done by the checkEnemyMoveToCapture algorithm. By checking if the end coord second index in comparison to the start coord second index value. It determines if the the new destination coord is going to be left or right of current destination coord. Next part of the algorithm is to compare the first value of endcoord char array with the letter char array using a for loop. When the end coord = letter index - 1, the index value is stored in a string. This will comprise the first element, letter, of the new destination coord.
    The second element, number, of the new destination coord is found in a similar fashion: by comparing the second index of destination coords with the number char array and storing the value of number char array when this = destination index 2 - 1. The two values are then concatenated to form the coords of the new destination of the player piece. 
    
    The new destination coords are checked to see if the exist AND there is no piece belonging to  either current player or opponent player. If this condition is met. The player piece is moved, similar to moving a player piece where an opponents piece is not present. The only addition to this is the opponents piece is removed from the board and the opponents player piece count is reduced by one. This is done automatically, and no undo feature is available, presently.
    Else, the move is not possible and nothing happens. See below:
    
    INSERT ALGORITHM HERE!!!!!!
    
    \subsubsection{Capture Second Opponent Piece}
    If an opponents piece has been taken, the variable for player piece start coord is set to the new destination coord from taking an opponents piece. And two new coords are looked for: the left and right forward of the new start coord. These are then checked to see if they exist on the board AND they contain an opponent piece. If yes then an attempt is made to capture a second opponent piece. This is done exactly the same as capturing the first piece. Moving the player piece further down the board. This is also done automatically. With no input from the user to confirm this move. There is no option to undo this move.
    Else a second piece is not captured and the opponent player makes their turn.
    \subsubsection{King Pieces}
    \subsubsection{Player 2}
    Player 2 development is pretty much the same as player 1. Only certain algorithm arithmetic was changed around: + becomes - \& - becomes +
    \subsection{Player vs Computer}    
    \subsubsection{Computer}
    \paragraph{Computer vs Computer}
    \subsection{Undo/Redo}
    \subsection{Enhancements}
\section{Evaluation}
	\subsection{Critical Evaluation}
	\subsection{Personal Evaluation}	
\bibliographystyle{ieeetr}
\bibliography{references}
		
\end{document}